// backend/controllers/callController.js

import CallModel from "../Model/CallModel.js";

// Start a call (ringing)
export const startCall = async (req, res) => {
  try {
    const { caller, receiver, callType } = req.body;

    if (!caller || !receiver || !callType) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    const newCall = new CallModel({
      caller,
      receiver,
      callType,
      status: "missed", // default while ringing
    });

    await newCall.save();

    // If a Stream token was generated by middleware, return it to the client
    // so frontend components (like `VideoCall`) can initialize StreamVideo.
    const token = req.token || null;
    const apiKey = req.streamApiKey || null;
    const appId = req.streamAppId || null;

    res.status(201).json({
      message: "Call started",
      callId: newCall._id,
      token,
      apiKey,
      appId,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};

// Answer a call
export const answerCall = async (req, res) => {
  try {
    const { callId } = req.params;

    if (!callId) {
      return res.status(400).json({ message: "Call ID is required" });
    }

    const call = await CallModel.findById(callId);
    if (!call) return res.status(404).json({ message: "Call not found" });

    call.status = "accepted";
    call.startTime = new Date();
    await call.save();

    res.json({ message: "Call answered", call });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};

// End a call
export const endCall = async (req, res) => {
  try {
    const { callId, endReason } = req.body;

    const call = await CallModel.findById(callId);
    if (!call) return res.status(404).json({ message: "Call not found" });

    call.status = "ended";
    call.endTime = new Date();
    call.endReason = endReason || "user-ended";

    // Calculate duration in seconds
    if (call.startTime) {
      call.durationSeconds = Math.floor(
        (call.endTime.getTime() - call.startTime.getTime()) / 1000
      );
    }

    await call.save();

    res.json({ message: "Call ended", call });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};

// Reject a call
export const rejectCall = async (req, res) => {
  try {
    const callId = req.params.callId || req.body.callId;
    const { reason } = req.body;

    if (!callId) {
      return res.status(400).json({ message: "Call ID is required" });
    }

    const call = await CallModel.findById(callId);
    if (!call) return res.status(404).json({ message: "Call not found" });

    call.status = "rejected";
    call.endTime = new Date();
    call.endReason = reason || "rejected";

    await call.save();

    res.json({ message: "Call rejected", call });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};

// Get call history for a user
export const getCallHistory = async (req, res) => {
  try {
    const { userId } = req.params;

    const calls = await CallModel.find({
      $or: [{ caller: userId }, { receiver: userId }],
    })
      .sort({ createdAt: -1 })
      .limit(50);

    res.json({ calls });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};

// Return a Stream token for a given user (caller param in body)
export const getToken = async (req, res) => {
  try {
    const token = req.token || null;
    const apiKey = req.streamApiKey || null;
    const appId = req.streamAppId || null;

    if (!token)
      return res.status(500).json({ message: "Token generation failed" });

    res.json({ token, apiKey, appId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
};
